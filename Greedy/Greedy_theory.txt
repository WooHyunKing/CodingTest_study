Greedy algorithm은 **“단순”하지만 “강력”한 문제 해결 방법**이다.

어떠한 문제가 있을 때 단순 무식하게, 탐욕적으로 문제를 푸는 알고리즘이다.

현재 상황에서 지금 당장 좋은 것만 선택하는 방법으로, 매 순간 가장 좋아보이는 것을 선택하며 현재의 선택이 나중에 미칠 영향에 대해서는 고려하지 않는다 !

그리디 알고리즘은 사전에 외우고 있지 않아도 풀 수 있는 가능성이 높은 문제 유형이다.

반면에 정렬, 최단 경로와 같은 타 알고리즘 유형은 이미 그 알고리즘의 사용법을 정확히 알고 있어야 해결 가능한 경우가 많다.

그리디 알고리즘 자체가 문제 출제의 폭이 매우 넓기 때문에 다익스트라 알고리즘과 같은 특이 케이스를 제외하고는 단순 암기를 통해 모든 문제를 대처하기 어렵다.

그리디 알고리즘 유형의 문제는 창의력, 즉 문제를 풀기 위한 최소한의 아이디어를 떠올릴 수 있는 능력을 요구한다.

다시말해 특정한 문제를 만났을 때 단순히 현재 상황에서 가장 좋아 보이는 것만 선택해도 문제를 풀 수 있는지를 파악할 수 있어야 한다.

그리디 알고리즘의 기준은 정렬 알고리즘을 사용했을 때 만족시킬 수 있으므로 그리디 알고리즘 문제는 자주 정렬 알고리즘과 짝을 이뤄 출제된다.

다음 코드는 그리디 알고리즘의 대표적인 예시인 거스름돈 문제의 코드이다.

```python
n = 1260
count = 0

# 큰 단위의 화폐부터 차례대로 확인
coin_types = [500,100,50,10]

for coin in coin_types:
	count += n // coin
	n %= coin

print(count)
```

위 코드에서는 화폐의 종류만큼 반복을 수행하므로 화폐의 종류가 N개라고 할 때 시간 복잡도는 O(N)이다.

즉, 이 알고리즘의 시간 복잡도는 동전의 총 종류에만 영향을 받고 거스름돈의 크기와는 무관하다.

# 그리디 알고리즘의 정당성

대부분의 문제는 그리디 알고리즘을 이용했을 때 ‘최적의 해’를 찾을 수 없을 가능성이 높다.

하지만 탐욕적으로 문제에 접근했을 때 정확한 답을 찾을 수 있다는 보장이 있을 때는 매우 효과적이고 직관적이다.

그리디 알고리즘으로 문제의 해법을 찾았을 때는 그 해법이 정당한지 “검토”해야 한다.

거스름돈 문제를 그리디 알고리즘으로 해결할 수 있는 이유는 가지고 있는 동전 중에서 큰 단위가 항상 작은 단위의 배수이므로 작은 단위의 동전들을 종합해 다른 해가 나올 수 없기 때문이다.

대부분의 그리디 알고리즘 문제에서는 이처럼 문제 풀이를 위한 ‘최소한의 아이디어’를 떠올리고 이것이 ‘정당한지 검토’할 수 있어야 답을 도출할 수 있다.